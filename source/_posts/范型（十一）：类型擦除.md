title: 范型（十一）：类型擦除
tags:
  - Java
categories:
  - 语言
  - Java
date: 2016-12-14 13:53:00
---


Java 语言引入范型是为了在编译期提供严谨的类型检查和支持范型编程。为了实现范型，Java 编译器应用类型擦除：

- 替换所有范型类型中的类型参数，用它们的边界或者 Object（如果类型参数是无界的）。因此，生成的字节码只包含普通的类、接口和方法。
- 如果为了保护类型安全不要则插入类型转换。
- 生成桥接方法来保护继承范型类型中的多态。

<!-- more -->

类型擦除确保对于参数化类型没有新类被创建；因此，范型不会引起运行时消耗。

### 范型类型的擦除

在类型擦除的过程中，Java 编译器擦除所有类型参数，如果类型参数是有界的则用它的第一边界替换每个类型参数，或者用 Object替换，如果类型参数是无界的。

考虑下面的范型类，展示了单向列表中的一个节点：

    public class Node<T> {

      private T data;
      private Node<T> next;

      public Node(T data, Node<T> next) }
        this.data = data;
        this.next = next;
      }

      public T getData() { return data; }
      // ...
    }

因为类型参数 T 是无界的，Java 编译器用 Object 替换它：

    public class Node {

      private Object data;
      private Node next;

      public Node(Object data, Node next) {
        this.data = data;
        this.next = next;
      }

      public Object getData() { return data; }
      // ...
    }

在下面的例子中，范型类 Node 使用一个有界类型参数：

    public class Node<T extends Comparable<T>> {

      private T data;
      private Node<T> next;

      public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
      }

      public T getData() { return data; }
      // ...
    }

Java 编译器用第一边界类 Comparable 替换有界类型参数 T：

    public class Node {

      private Comparable data;
      private Node next;

      public Node(Comparable data, Node next) {
        this.data = data;
        this.next = next;
      }

      public Comparable getData() { return data; }
      // ...
    }

### 范型方法的擦除

Java 编译器也擦除范型方法参数中的类型参数。考虑下面的范型方法：

    // Counts the number of occurrences of elem in anArray.
    //
    public static <T> int count(T[] anArray, T elem) {
      int cnt = 0;
      for (T e : anArray)
        if (e.equals(elem))
          ++cnt;
        return cnt;
    }

因为 T 是无界的，Java 编译器用 Object 替换它：

    public static int count(Object[] anArray, Object elem) {
      int cnt = 0;
      for (Object e : anArray)
        if (e.equals(elem))
            ++cnt;
        return cnt;
    }

假设定义了下面的类：

    class Shape { /* ... */ }
    class Circle extends Shape { /* ... */ }
    class Rectangle extends Shape { /* ... */ }

可以写一个范型方法来画不同的形状：

    public static <T extends Shape> void draw(T shape) { /* ... */ }

Java 编译器用 Shape 替换 T：

    public static void draw(Shape shape) { /* ... */ }

### 类型擦除和桥接方法的作用

有时类型擦除会引起一种不可预期的情况。下面的例子展示了这种情况是如何发生的。这个例子（在[桥接方法](http://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html#bridgeMethods)中描述的）展示了编译器如何创建一个作为类型擦除过程中一部分的合成方法（叫做桥接方法）。

给出下面两个类：

    public class Node<T> {

      public T data;

      public Node(T data) { this.data = data; }

      public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
      }
    }

    public class MyNode extends Node<Integer> {
      public MyNode(Integer data) { super(data); }

      public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
      }
    }

考虑下面的代码：

    MyNode mn = new MyNode(5);
    Node n = mn;            // A raw type - compiler throws an unchecked warning
    n.setData("Hello");     
    Integer x = mn.data;    // Causes a ClassCastException to be thrown.

类型擦除后，代码变为：

    MyNode mn = new MyNode(5);
    Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning
    n.setData("Hello");
    Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.

代码被执行时会发生这些：

- n.setData("Hello"); 引起 MyNode 类对象的 setData(Object) 方法被执行。（MyNode 类从 Node 继承 setData(Object)。）
- setData(Object) 的方法体中，n 指向的对象的 data 属性被赋值了一个 String。
- 同一个对象的 data 属性（mn 指向的对象）可以被访问且希望是一个 integer（因为 mn 是 MyNode 的对象，MyNode 是 Node<Integer>）。
- 尝试赋值一个 String 给一个 Integer 引起一个 ClassCastException（来自被 Java 编译器在赋值中插入的类型转化）。

#### 桥接方法

当编译一个继承参数化类或实现参数化接口的类或接口时，编译器可能需要创建一个作为类型擦除过程中一部分的合成方法（叫做桥接方法）。通常不需要担心桥接方法，但在跟踪栈中出现时可能会使你困惑。

类型擦除之后，Node 和 MyNode 类变为：

    public class Node {

      public Object data;

      public Node(Object data) { this.data = data; }

      public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
      }
    }

    public class MyNode extends Node {

      public MyNode(Integer data) { super(data); }

      public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
      }
    }

类型擦除之后，方法特征并不匹配。Node 方法变为 setData(Object)，MyNode 方法变为 setData(Integer)。因此，MyNode setData 方法不是重载 Node setData 方法。

为了解决这个问题，并保持类型擦除后范型类型的[多态性](http://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html)，Java 编译器生成一个桥接方法来保证子类型化像期望的一样工作。对于 MyNode 类，编译器为 setData 生成下面的桥接方法：

    class MyNode extends Node {

      // Bridge method generated by the compiler
      //
      public void setData(Object data) {
        setData((Integer) data);
      }

      public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
      }

      // ...
    }

像你看到的，桥接方法与 Node 类的 setData 方法类型擦除后有相同的方法特征，代表原来的 setData 方法。

### 非范型具体化类型

[类型擦除](http://docs.oracle.com/javase/tutorial/java/generics/erasure.html)一节讨论了编译器移除类型参数相关的过程。类型擦除关于变量参数（也被称为可变参数）方法有重要地位，变量参数方法的可变的形式参数有一个非范型具体化类型。参见[将信息传递给方法或构造函数](http://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html)中的[任意数量参数](http://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html#varargs)一节获取关于可变参数方法的更多信息。

这页内容覆盖下面的主题：

- [非范型具体化类型](http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#non-reifiable-types)
- [堆污染](http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#heap_pollution)
- [有非范型具体化形式参数的可变参数方法的潜在漏洞](http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#vulnerabilities)
- [从非范型具体化形式参数的可变参数方法预防警告](http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#suppressing)

#### 非范型具体化类型

一个可具体化的类型是在运行时类型信息完全可用的类型。这包含原生类型、非范型类型、原始类型和无界通配符的调用。

非范型具体化类型是通过类型擦除在编译期被移除信息的类型 - 非无界通配符范型类型的调用。非范型具体化类型不能在运行时获取它的所有信息。非范型具体化类型的例子是 List<String> 和 List<Number>；JVM 在运行时不知道这些类型的差别。如在[范型限制](http://docs.oracle.com/javase/tutorial/java/generics/restrictions.html)中展示的，不能使用非范型具体化类型的情况：例如，在 instanceof 表达式中或者作为数组中的元素。

#### 堆污染

堆污染发生在一个参数化类型变量指向一个不是这个参数化类型的对象。如果程序执行一些在编译期产生一个未检查告警的操作，这种情况就会发生。如果涉及参数化类型操作（例如，类型转换或方法调用）的正确性不能被核查，不管是在编译期（在编译期类型检查规则范围内）或是在运行时，会生成一个未检查告警。例如，堆污染会发生在原始类型和参数化类型混合使用的时候，或者执行未检查类型转换的时候。

常规情况下，所有代码同时被编译时，编译器放出一个未检查告警来引起你对潜在堆污染的注意。如果分别单独编译你的各部分代码，发现潜在的堆污染风险就很困难。如果确保代码没有编译警告，那么就没有堆污染发生。

#### 有非范型具体化形式参数的可变参数方法的潜在漏洞

包含可变输入参数的范型方法可能引起堆污染。

考虑下面的 ArrayBuilder 类：

    public class ArrayBuilder {

      public static <T> void addToList (List<T> listArg, T... elements) {
        for (T x : elements) {
          listArg.add(x);
        }
      }

      public static void faultyMethod(List<String>... l) {
        Object[] objectArray = l;     // Valid
        objectArray[0] = Arrays.asList(42);
        String s = l[0].get(0);       // ClassCastException thrown here
      }

    }

下面的例子，HeapPollutionExample 使用 ArrayBuiler 类：

    public class HeapPollutionExample {

      public static void main(String[] args) {

        List<String> stringListA = new ArrayList<String>();
        List<String> stringListB = new ArrayList<String>();

        ArrayBuilder.addToList(stringListA, "Seven", "Eight", "Nine");
        ArrayBuilder.addToList(stringListB, "Ten", "Eleven", "Twelve");
        List<List<String>> listOfStringLists = new ArrayList<List<String>>();
        ArrayBuilder.addToList(listOfStringLists, stringListA, stringListB);

        ArrayBuilder.faultyMethod(Arrays.asList("Hello!"), Arrays.asList("World!"));
      }
    }

当编译时，ArrayBuilder.addToList 方法定义会产生下面的告警：

    warning: [varargs] Possible heap pollution from parameterized vararg type T

当编译器遇到一个可变参数的方法时，它转化可变常规参数为一个数组。然而，Java 编程语言不保证参数化类型数组的创建。在 ArrayBuilder.addToList 方法中，编译器转化可变参数 T... elements 为一个常规数组参数 T[] elements。然而，因为类型擦除，编译器转换可变常规参数为 Object[] elements。因此，存在堆污染的可能性。

下面的表达式赋值可变常规参数 l 给 Object 数组 objectArgs：

    Object[] objectArray = l;

这个表达式会产生潜在的堆污染。匹配可变常规参数 l 的参数化类型的值可以被赋值给 objectArray 变量，因此可以被赋给 l。但是，编译器不会在这个表达式上生成未检查告警。编译器已经在转化可变常规参数 List<String>... l 到常规参数 List[] l 时生成了告警。这个表达式是有效的；变量 l 的类型是 List[]（Object[] 的子类型）。

因此，如果通过下面展示的表达式赋值任何类型的 List 对象给 objectArray 数组的任何数组元素，编译器不会显示告警或错误：

    objectArray[0] = Arrays.asList(42);

这个表达式给 objectArray 数组的第一个元素赋值一个包含一个 Integer 类型对象的 List 对象。

假设用下面的表达式调用 ArrayBuilder.faultyMethod：

    ArrayBuilder.faultyMethod(Arrays.asList("Hello!"), Arrays.asList("World!"));

在运行时，JVM 在下面的表达式中抛出一个 ClassCastException：

    // ClassCastException thrown here
    String s = l[0].get(0);

存储在变量 l 数组的第一个元素是 List<Integer> 类型，但是这个表达式希望得到一个 List<String> 类型的对象。

#### 从非范型具体化形式参数的可变参数方法预防警告

如果声明一个有参数化类型参数的可变参数方法，你需要确认方法体不会抛出 ClassCastException 或因为不适当的处理可变常规参数引起的其他类似异常，可以通过给静态或非构造方法声明添加下面的注解防止编译器针对可变参数方法生成的这些类型的告警：

    @SafeVarargs

@SafeVarargs 注解是方法协议文档化的一部分；这个注解断言方法的实现会恰当处理可变常规参数。

添加下面的内容到方法的声明来防止这样的告警也是勉强可取的：

    @SuppressWarnings({"unchecked", "varargs"})

然而，这种方法不能防止从方法调用端生成的告警。如果对 @SuppressWarnings 语法不熟悉，参见[注解](http://docs.oracle.com/javase/tutorial/java/annotations/index.html)。
